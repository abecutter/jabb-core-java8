/**
 * 
 */
package net.sf.jabb.taskqueues;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.List;

/**
 * Queues of tasks that need to be executed at specified times and may have a predecessor.
 * <ul>
 * 	<li>expectedExecutionTime: the task will not be dequeue-able before this time.</li>
 * 	<li>predecessorId: the task will not be dequeue-able if another task with that ID exists in any queue.</li>
 * 	<li>leasePeriod: the period that a task remains in the queue but invisible. When dequeueing tasks, a leasePeriod must be specified by the consumer.</li> 
 * 	<li>ID of the task: They are generated by the service and are guaranteed to be unique across queues provided by the same server.</li>
 * </ul>
 * 
 * @author James Hu
 *
 */
public interface TaskQueues {
	/**
	 * Put a task into the queue.
	 * @param queue		id/name of the queue
	 * @param task		the task
	 * @param expectedExecutionTime		the time that the task needs to be executed
	 * @param predecessorId				ID of the predecessor task. This task will not be visible until the predecessor task has been deleted.
	 * @return	ID of the just enqueued task
	 */
	String put(String queue, Serializable task, Instant expectedExecutionTime, String predecessorId);
	
	/**
	 * Put a task into the queue.
	 * @param queue		id/name of the queue
	 * @param task		the task
	 * @param expectedExecutionTime		the time that the task needs to be executed
	 * @param predecessorId				ID of the predecessor task. This task will not be visible until the predecessor task has been deleted.
	 * @return	ID of the just enqueued task
	 */
	default String put(String queue, Serializable task, Duration expectedExecutionDelay, String predecessorId){
		return put(queue, task, Instant.now().plus(expectedExecutionDelay), predecessorId);
	}

	/**
	 * Put a task into the queue. The task has no predecessor thus its predecessorId will be set to null.
	 * @param queue		id/name of the queue
	 * @param task		the task
	 * @param expectedExecutionTime		the time that the task needs to be executed
	 * @return	ID of the just enqueued task
	 */
	default String put(String queue, Serializable task, Instant expectedExecutionTime){
		return put(queue, task, expectedExecutionTime, null);
	}
	
	/**
	 * Put a task into the queue, and let the expected execution time of the task to be now.
	 * @param queue		id/name of the queue
	 * @param task		the task
	 * @param expectedExecutionDelay  the delay after which the task is expected to be executed
	 * @return	ID of the just enqueued task
	 */
	default String put(String queue, Serializable task, Duration expectedExecutionDelay){
		return put(queue, task, Instant.now().plus(expectedExecutionDelay), null);
	}
	
	/**
	 * Put a task into the queue, and let the expected execution time of the task to be now.
	 * @param queue		id/name of the queue
	 * @param task		the task
	 * @return	ID of the just enqueued task
	 */
	default String put(String queue, Serializable task){
		return put(queue, task, Instant.now(), null);
	}
	
	/**
	 * Put a task into the queue, and let the expected execution time of the task to be now.
	 * @param queue		id/name of the queue
	 * @param task		the task
	 * @param predecessorId				ID of the predecessor task. This task will not be visible until the predecessor task has been deleted.
	 * @return	ID of the just enqueued task
	 */
	default String put(String queue, Serializable task, String predecessorId){
		return put(queue, task, Instant.now(), predecessorId);
	}
	
	/**
	 * Get tasks from the queues by (where queue = :queues and expectedExecutionTime <= :expectedExecutionTime and not exists (where id = :predecessorId) order by expectedExecutionTime, enqueuedTime limit :limit). 
	 * And for those returned tasks, on server side they will be updated by setting (lastConsumer = :consumerId, expectedExecutionTime = NOW() + :visibilityTimeout)
	 * @param queue	The queue in which tasks will be retrieved
	 * @param expectedExecutionTime		All returned tasks must have an expected execution time no later than this parameter
	 * @param limit		the maximum number of tasks to be returned
	 * @param consumerId	The ID of the caller/consumer. This ID will be used to update the task meta data
	 * @param leasePeriod		The duration for this task to be kept invisible in the queue
	 * @return	A list of tasks sorted by (queuePriority, expectedExecutionTime, enqueuedTime)
	 */
	List<QueuedTask> get(String queue, Instant expectedExecutionTime, int limit, String consumerId, Duration leasePeriod);
	
	/**
	 * Get tasks from the queues by (where queue = :queues and expectedExecutionTime <= :NOW() and not exists (where id = :predecessorId) order by expectedExecutionTime, enqueuedTime limit :limit). 
	 * And for those returned tasks, on server side they will be updated by setting (lastConsumer = :consumerId, expectedExecutionTime = NOW() + :visibilityTimeout)
	 * @param queue	The queue in which tasks will be retrieved
	 * @param limit		the maximum number of tasks to be returned
	 * @param consumerId	The ID of the caller/consumer. This ID will be used to update the task meta data
	 * @param leasePeriod		The duration for this task to be kept invisible in the queue
	 * @return	A list of tasks sorted by (queuePriority, expectedExecutionTime, enqueuedTime)
	 */
	default List<QueuedTask> get(String queue, int limit, String consumerId, Duration leasePeriod){
		return get(queue, Instant.now(), limit, consumerId, leasePeriod);
	}
	
	
	/**
	 * Remove a task from the queue. If the task cannot be found in the queue, this method will succeed.
	 * If the task is not currently owned by the consumer, an exception will be thrown.
	 * The effect is deleting (where id = :id and lastConsumer = :consumerId)
	 * @param id	ID of the task
	 * @param consumerId 	ID of the consumer
	 */
	void delete(String id, String consumerId);
	
	/**
	 * Update the lease period.
	 * If the task cannot be found or it is not currently owned by the consumer, an exception will be thrown.
	 * The effect is updating (expectedExecutionTime = NOW() + leasePeriod where id = :id and lastConsumer = :consumerId)
	 * @param id			ID of the task
	 * @param consumerId	ID of the consumer
	 * @param leasePeriod	the lease period from now	
	 */
	void update(String id, String consumerId, Duration leasePeriod);
}
