/**
 * 
 */
package net.sf.jabb.transprogtracker;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.UUID;

/**
 * Tracker of transactional processing progress.
 * For any progress, at any time there is only one transactional processing in progress.
 * <ul>
 * 	<li>ID of the transaction: They can be generated by the service and can also be specified by the client. They are NOT guaranteed to be unique across progresses.</li>
 * </ul>
 * @author James Hu
 *
 */
public interface TransactionalProgressTracker {
	
	/**
	 * Acquire a lease on a progress. At any time only one processor can have the lease of the progress.
	 * If a processor tries to acquire a new lease while it is already holding an existing lease, 
	 * the acquisition will succeed and the new lease starts from the time the method is called.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leaseExpirationTimed	the expiration time of the lease
	 * @return	true if a lease successfully acquired, false otherwise.
	 */
	boolean acquireLease(String progressId, String processorId, Instant leaseExpirationTimed);

	/**
	 * Acquire a lease on a progress. At any time only one processor can have the lease of the progress.
	 * If a processor tries to acquire a new lease while it is already holding an existing lease, 
	 * the acquisition will succeed and the new lease starts from the time the method is called.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leasePeriod	period of the lease
	 * @return	true if a lease successfully acquired, false otherwise.
	 */
	default boolean acquireLease(String progressId, String processorId, Duration leasePeriod){
		return acquireLease(progressId, processorId, Instant.now().plus(leasePeriod));
	}
	
	/**
	 * Renew the lease already acquired. The process must already hold a valid lease. 
	 * After the renew, the start time of the lease is unchanged and the expiration time of the lease is updated to the one specified by the argument.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leaseExpirationTimed	the new expiration time of the lease
	 * @return true if successfully renewed, false otherwise
	 */
	boolean renewLease(String progressId, String processorId, Instant leaseExpirationTimed);
	
	/**
	 * Renew the lease already acquired. The process must already hold a valid lease. 
	 * After the renew, the start time of the lease is unchanged and the expiration time of the lease is updated to the one specified by the argument.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leasePeriod	period of the lease from now
	 * @return true if successfully renewed, false otherwise
	 */
	default boolean renewLease(String progressId, String processorId, Duration leasePeriod){
		return renewLease(progressId, processorId, Instant.now().plus(leasePeriod));
	}
	
	/**
	 * Release the lease. Releasing an already expired lease will succeed.
	 * Releasing a lease while the processor does not currently hold will also succeed.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @return true if successfully released, false otherwise
	 */
	boolean releaseLease(String progressId, String processorId);
	
	/**
	 * Get the ID of the processor that currently holding the lease of the progress
	 * @param progressId		ID of the progress
	 * @return		ID of the processor, or null if the subject is not currently on lease
	 */
	String getProcessor(String progressId);
	

	/**
	 * Start a transaction
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param endPosition		the end position, for example the sequence number in input data stream
	 * @param timeout			The time that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @param transactionId		The ID of this transaction, can be null if an ID generated by the system should be used
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException 
	 * @throws NotOwningLeaseException 
	 */
	String startTransaction(String progressId, String processorId, String startPosition, String endPosition, Instant timeout, Serializable transaction, String transactionId) throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException;
	
	/**
	 * Start a transaction without specifying the transaction ID. The transaction ID will be generated inside this method.
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param endPosition		the end position, for example the sequence number in input data stream
	 * @param timeout			The time that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException 
	 * @throws NotOwningLeaseException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, String endPosition, Instant timeout, Serializable transaction) throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException{
		return startTransaction(progressId, processorId, startPosition, endPosition, timeout, transaction, UUID.randomUUID().toString());
	}

	/**
	 * Finish a succeeded transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 */
	void finishTransaction(String progressId, String processorId, String transactionId) throws NotOwningTransactionException;
	
	/**
	 * Abort a transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 */
	void abortTransaction(String progressId, String processorId, String transactionId) throws NotOwningTransactionException;
	
	/**
	 * Retry a transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 */
	void retryTransaction(String progressId, String processorId, String transactionId) throws NotOwningTransactionException;
	
	/**
	 * Update the time out of a transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeout				The new time that the transaction should time out
	 * @throws NotOwningTransactionException 
	 */
	void renewTransactionTimeout(String progressId, String processorId, String transactionId, Instant timeout) throws NotOwningTransactionException;
	
	/**
	 * Update the time out of a transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeout				The period from now after which the transaction should time out
	 * @throws NotOwningTransactionException 
	 */
	default void renewTransactionTimeout(String progressId, String processorId, String transactionId, Duration timeout) throws NotOwningTransactionException{
		renewTransactionTimeout(progressId, processorId, transactionId, Instant.now().plus(timeout));
	}
	
	/**
	 * Check if a transaction had succeeded before a specific time
	 * @param progressId			ID of the progress
	 * @param transactionId			ID of the transaction
	 * @param beforeWhen			The time before which we want to know whether the transaction had succeeded or not 
	 * @return	true if the transaction had succeeded in the past or does not exist. false if the transaction is in-progress, aborted, or just succeeded a extremely short while ago.
	 */
	boolean isTransactionSuccessful(String progressId, String transactionId, Instant beforeWhen);
	
	/**
	 * Get the last succeeded transaction of a progress
	 * @param progressId	ID of the progress
	 * @return				The last succeeded transaction, or null if there is none.
	 */
	ProgressTransaction getLastSuccessfulTransaction(String progressId);
	
}
