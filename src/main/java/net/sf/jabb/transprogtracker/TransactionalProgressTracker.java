/**
 * 
 */
package net.sf.jabb.transprogtracker;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.UUID;

import net.sf.jabb.transprogtracker.ex.IllegalTransactionStateException;
import net.sf.jabb.transprogtracker.ex.InfrastructureErrorException;
import net.sf.jabb.transprogtracker.ex.LastTransactionIsNotSuccessfulException;
import net.sf.jabb.transprogtracker.ex.NotCurrentTransactionException;
import net.sf.jabb.transprogtracker.ex.NotOwningLeaseException;
import net.sf.jabb.transprogtracker.ex.NotOwningTransactionException;
import net.sf.jabb.transprogtracker.ex.TransactionTimeoutAfterLeaseExpirationException;

/**
 * Tracker of transactional processing progress.
 * For any progress, at any time there is only one transactional processing in progress.
 * <ul>
 * 	<li>ID of the transaction: They can be generated by the service and can also be specified by the client. They are NOT guaranteed to be unique across progresses.</li>
 * </ul>
 * @author James Hu
 *
 */
public interface TransactionalProgressTracker {
	
	/**
	 * Acquire a lease on a progress. At any time only one processor can have the lease of the progress.
	 * If a processor tries to acquire a new lease while it is already holding an existing lease, 
	 * the acquisition will succeed and the new lease starts from the time the method is called.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leaseExpirationTimed	the expiration time of the lease
	 * @return	true if a lease successfully acquired, false otherwise.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	boolean acquireLease(String progressId, String processorId, Instant leaseExpirationTimed) throws InfrastructureErrorException;

	/**
	 * Acquire a lease on a progress. At any time only one processor can have the lease of the progress.
	 * If a processor tries to acquire a new lease while it is already holding an existing lease, 
	 * the acquisition will succeed and the new lease starts from the time the method is called.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leasePeriod	period of the lease
	 * @return	true if a lease successfully acquired, false otherwise.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default boolean acquireLease(String progressId, String processorId, Duration leasePeriod) throws InfrastructureErrorException{
		return acquireLease(progressId, processorId, Instant.now().plus(leasePeriod));
	}
	
	/**
	 * Renew the lease already acquired. The process must already hold a valid lease. 
	 * After the renew, the start time of the lease is unchanged and the expiration time of the lease is updated to the one specified by the argument.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leaseExpirationTimed	the new expiration time of the lease
	 * @return true if the lease is still valid and has been successfully renewed, false otherwise
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	boolean renewLease(String progressId, String processorId, Instant leaseExpirationTimed) throws InfrastructureErrorException;
	
	/**
	 * Renew the lease already acquired. The process must already hold a valid lease. 
	 * After the renew, the start time of the lease is unchanged and the expiration time of the lease is updated to the one specified by the argument.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @param leasePeriod	period of the lease from now
	 * @return true if the lease is still valid and has been successfully renewed, false otherwise
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default boolean renewLease(String progressId, String processorId, Duration leasePeriod) throws InfrastructureErrorException{
		return renewLease(progressId, processorId, Instant.now().plus(leasePeriod));
	}
	
	/**
	 * Release the lease. 
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws NotOwningLeaseException if the processor does not currently own a valid lease
	 */
	void releaseLease(String progressId, String processorId) throws InfrastructureErrorException, NotOwningLeaseException;
	
	/**
	 * Release the lease.
	 * @param progressId		ID of the progress
	 * @param processorId	ID of the processor
	 * @return true if there was a valid lease owned by the processor and it has been successfully released, false if the processor does not own a lease
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default boolean releaseLeaseIfOwning(String progressId, String processorId) throws InfrastructureErrorException{
		try {
			releaseLease(progressId, processorId);
			return true;
		} catch (NotOwningLeaseException e) {
			return false;
		}
	}

	/**
	 * Get the ID of the processor that currently holding the lease of the progress
	 * @param progressId		ID of the progress
	 * @return		ID of the processor, or null if the subject is not currently on lease
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	String getProcessor(String progressId) throws InfrastructureErrorException;
	

	/**
	 * Start a transaction
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param endPosition		the end position, for example the sequence number in input data stream
	 * @param timeout			The time that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @param transactionId		The ID of this transaction, can be null if an ID generated by the system should be used
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException if a new transaction cannot be started because the last transaction needs to be retried first
	 * @throws NotOwningLeaseException if the processor does not currently own a valid lease
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 */
	String startTransaction(String progressId, String processorId, String startPosition, String endPosition, 
			Instant timeout, Serializable transaction, String transactionId) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException;
	
	/**
	 * Start a transaction
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param endPosition		the end position, for example the sequence number in input data stream
	 * @param timeoutDuration	The duration after that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @param transactionId		The ID of this transaction, can be null if an ID generated by the system should be used
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException 
	 * @throws NotOwningLeaseException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, String endPosition, 
			Duration timeoutDuration, Serializable transaction, String transactionId) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, endPosition, Instant.now().plus(timeoutDuration), transaction, transactionId);
	}

	/**
	 * Start a transaction without specifying the transaction ID. The transaction ID will be generated inside this method.
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param endPosition		the end position, for example the sequence number in input data stream
	 * @param timeout			The time that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException 
	 * @throws NotOwningLeaseException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, String endPosition, 
			Instant timeout, Serializable transaction) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, endPosition, timeout, transaction, UUID.randomUUID().toString());
	}
	
	/**
	 * Start a transaction without specifying the transaction ID. The transaction ID will be generated inside this method.
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param endPosition		the end position, for example the sequence number in input data stream
	 * @param timeoutDuration	The duration after that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException 
	 * @throws NotOwningLeaseException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, String endPosition, 
			Duration timeoutDuration, Serializable transaction) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, endPosition, Instant.now().plus(timeoutDuration), transaction, UUID.randomUUID().toString());
	}

	
	/**
	 * Start a transaction
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param timeout			The time that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @param transactionId		The ID of this transaction, can be null if an ID generated by the system should be used
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException
	 * @throws NotOwningLeaseException
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, Instant timeout, 
			Serializable transaction, String transactionId) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, null, timeout, transaction, transactionId);
	}

	/**
	 * Start a transaction
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param timeoutDuration	The duration after that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @param transactionId		The ID of this transaction, can be null if an ID generated by the system should be used
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException
	 * @throws NotOwningLeaseException
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, Duration timeoutDuration, 
			Serializable transaction, String transactionId) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, null, Instant.now().plus(timeoutDuration), transaction, transactionId);
	}

	/**
	 * Start a transaction without specifying the transaction ID. The transaction ID will be generated inside this method.
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param timeout			The time that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException
	 * @throws NotOwningLeaseException
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, Instant timeout, 
			Serializable transaction) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, null, timeout, transaction, UUID.randomUUID().toString());
	}
	
	/**
	 * Start a transaction without specifying the transaction ID. The transaction ID will be generated inside this method.
	 * @param progressId			ID of the progress
	 * @param processorId		ID of the processor which must currently own the lease on the progress
	 * @param startPosition		the start position, for example the sequence number in input data stream
	 * @param timeoutDuration	The duration after that the transaction should time out
	 * @param transaction		details of the transaction, can be null if there is no need for that
	 * @return		The ID of this transaction
	 * @throws LastTransactionIsNotSuccessfulException
	 * @throws NotOwningLeaseException
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	default String startTransaction(String progressId, String processorId, String startPosition, Duration timeoutDuration, 
			Serializable transaction) 
					throws LastTransactionIsNotSuccessfulException, NotOwningLeaseException, InfrastructureErrorException, IllegalTransactionStateException, TransactionTimeoutAfterLeaseExpirationException{
		return startTransaction(progressId, processorId, startPosition, null, Instant.now().plus(timeoutDuration), transaction, UUID.randomUUID().toString());
	}
	

	/**
	 * Finish a succeeded transaction with a specified end position.
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the actual end position of the succeeded transaction, for example the sequence number in input data stream. 
	 * 								It can be null if the end position does not need to be updated
	 * @throws NotOwningTransactionException if either the transaction is not the current transaction or is not owned by the processor
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NotCurrentTransactionException 
	 * @throws NotOwningLeaseException 
	 */
	void finishTransaction(String progressId, String processorId, String transactionId, String endPosition) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NotCurrentTransactionException, NotOwningLeaseException;
	
	/**
	 * Finish a succeeded transaction without changing the end position of the transaction.
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NotCurrentTransactionException 
	 * @throws NotOwningLeaseException 
	 */
	default void finishTransaction(String progressId, String processorId, String transactionId) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NotCurrentTransactionException, NotOwningLeaseException{
		finishTransaction(progressId, processorId, transactionId, null);
	}

	
	/**
	 * Abort a transaction with a specified end position
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the actual end position of the succeeded transaction, for example the sequence number in input data stream. 
	 * 								It can be null if the end position does not need to be updated
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NotCurrentTransactionException 
	 * @throws NotOwningLeaseException 
	 */
	void abortTransaction(String progressId, String processorId, String transactionId, String endPosition) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NotCurrentTransactionException, NotOwningLeaseException;
	
	/**
	 * Abort a transaction without changing the endPosition of the transaction.
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NotCurrentTransactionException 
	 * @throws NotOwningLeaseException 
	 */
	default void abortTransaction(String progressId, String processorId, String transactionId) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NotCurrentTransactionException, NotOwningLeaseException{
		abortTransaction(progressId, processorId, transactionId, null);
	}
	
	/**
	 * Retry last unsuccessful transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param timeout			The time that the transaction should time out
	 * @return details of the transaction, or null if no transaction need to be retried
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws NotOwningLeaseException 
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 * @throws IllegalTransactionStateException 
	 */
	ProgressTransaction retryLastUnsuccessfulTransaction(String progressId, String processorId, Instant timeout) 
			throws NotOwningTransactionException, InfrastructureErrorException, NotOwningLeaseException, TransactionTimeoutAfterLeaseExpirationException, IllegalTransactionStateException;
	
	/**
	 * Update the time out of a transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeout				The new time that the transaction should time out
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws NotOwningLeaseException 
	 * @throws IllegalTransactionStateException 
	 * @throws NotCurrentTransactionException 
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 */
	void renewTransactionTimeout(String progressId, String processorId, String transactionId, Instant timeout) 
			throws NotOwningTransactionException, InfrastructureErrorException, NotOwningLeaseException, IllegalTransactionStateException, NotCurrentTransactionException, TransactionTimeoutAfterLeaseExpirationException;
	
	/**
	 * Update the time out of a transaction
	 * @param progressId			ID of the progress
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeout				The period from now after which the transaction should time out
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws NotOwningLeaseException 
	 * @throws IllegalTransactionStateException 
	 * @throws NotCurrentTransactionException 
	 * @throws TransactionTimeoutAfterLeaseExpirationException 
	 */
	default void renewTransactionTimeout(String progressId, String processorId, String transactionId, Duration timeout) 
			throws NotOwningTransactionException, InfrastructureErrorException, NotOwningLeaseException, IllegalTransactionStateException, NotCurrentTransactionException, TransactionTimeoutAfterLeaseExpirationException{
		renewTransactionTimeout(progressId, processorId, transactionId, Instant.now().plus(timeout));
	}
	
	/**
	 * Check if a transaction had succeeded before a specific time
	 * @param progressId			ID of the progress
	 * @param transactionId			ID of the transaction
	 * @param beforeWhen			The time before which we want to know whether the transaction had succeeded or not 
	 * @return	true if the transaction had succeeded in the past or does not exist. false if the transaction is in-progress, aborted, or just succeeded a extremely short while ago.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	boolean isTransactionSuccessful(String progressId, String transactionId, Instant beforeWhen) throws InfrastructureErrorException;
	
	/**
	 * Get the last succeeded transaction of a progress
	 * @param progressId	ID of the progress
	 * @return				The last succeeded transaction, or null if there is none.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	ProgressTransaction getLastSuccessfulTransaction(String progressId) throws InfrastructureErrorException;
	
}
