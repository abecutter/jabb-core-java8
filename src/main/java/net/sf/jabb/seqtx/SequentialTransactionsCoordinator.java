/**
 * 
 */
package net.sf.jabb.seqtx;

import java.time.Duration;
import java.time.Instant;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;

import net.sf.jabb.seqtx.ex.DuplicatedTransactionIdException;
import net.sf.jabb.seqtx.ex.IllegalEndPositionException;
import net.sf.jabb.seqtx.ex.IllegalTransactionStateException;
import net.sf.jabb.seqtx.ex.InfrastructureErrorException;
import net.sf.jabb.seqtx.ex.NoSuchTransactionException;
import net.sf.jabb.seqtx.ex.NotOwningTransactionException;

import org.apache.commons.lang3.Validate;

import com.google.common.base.Throwables;

/**
 * Coordinator of sequential transactions.
 * For a series of sequential transactions, there can be multiple on-going transactions being handled by different processors at any time.
 * Therefore, there is no need for processors to acquire and hold leases on the whole series.
 * However, all transactions are in a sequence disregarding the reliability of the processors:
 * <ul>
 * 	<li>For any transaction, there is always
 * 		a previous transaction (unless it is the first transaction) and there is no gap or overlap between its startPosition 
 * 		and the endPosition of the previous transaction.</li>
 * 	<li>For any transaction, there is always
 * 		a next transaction (unless it is the last transaction) and there is no gap or overlap between its endPosition 
 * 		and the startPosition of the next transaction.</li>
 * 	<li>Failed transactions (either explicitly aborted by the processor or caused by time out) will be retried until finally succeed.</li>
 * 	<li>Multiple processors can work on different ranges (specified by startPosition and endPosition) at the same time</li>
 * 	<li>There is a way to query whether a transaction has succeeded or 'not sure'</li>
 * </ul>
 * 
 * It is very suitable for coordinating the processing of records in Kafka, Microsoft Azure Event Hub, or Amazon AWS Kinesis.
 * 
 * About transaction IDs:
 * <ul>
 * 	<li>They can be either generated by the service or specified by the client/processor.</li>
 *  <li>The ID should never be a blank string.</li>
 *  <li>They have to be unique within a reasonable time period for any progress but don't need to be unique across transactionsByseriesId.</li>
 * </ul>
 * 
 * About start position and end position:
 * <ul>
 * 	<li>They are provided and interpreted by the application</li>
 *  <li>Start position can never be null</li>
 *  <li>A null end position means the transaction happens on an open range. Open range transactions can only be the last one in a series.
 *  	When finishing an open range transaction, the actual end position must be specified. An aborted or timed out open range transaction will be
 *  	removed therefore cannot be retried.</li>
 *  <li>End position can be updated when finishing the transaction only if the transaction is the last one in the series</li>
 * </ul>

 * Usage example:
 * <pre>
 * while(runFlag.get()){
 * 	SequentialTransaction transaction = null;
 * 	try{
 * 		transaction = tracker.startTransaction(seriesId, processorId, TIMEOUT_DURATION, MAX_IN_PROGRESS_TRANSACTIONS, MAX_RETRYING_TRANSACTIONS);
 * 		while (transaction != null && !transaction.hasStarted()){
 * 			String previousId = transaction.getTransactionId();
 * 			String previousEndPosition = transaction.getStartPosition();
 * 			transaction.setTransactionId(null);
 * 			int position = START_POSITION;
 * 			if (previousEndPosition != null){
 * 				position = findNextPosition(previousEndPosition);
 * 			}
 * 			if (position > END_POSITION){
 * 				transaction = null;
 * 				break;
 * 			}
 * 			transaction.setStartPosition(String.valueOf(position));
 * 			transaction.setEndPosition(findAvaileEndPosition(position));
 * 			transaction.setTimeout(TIMEOUT_DURATION);
 * 			transaction = tracker.startTransaction(seriesId, previousId, transaction, MAX_IN_PROGRESS_TRANSACTIONS, MAX_RETRYING_TRANSACTIONS);
 * 		}
 * 	}catch(InfrastructureErrorException | DuplicatedTransactionIdException e){
 * 		e.printStackTrace();
 * 	}catch(Exception e){
 * 		e.printStackTrace();
 * 	}
 * 	if (transaction != null){
 * 		doTransaction(transaction);
 * 	}else{
 * 		Uninterruptibles.sleepUninterruptibly(500, TimeUnit.MILLISECONDS);
 * 	}
 * }
 * </pre>
 * 
 * @author James Hu
 *
 */
public interface SequentialTransactionsCoordinator {
	
	/**
	 * Try to pick up a previously failed transaction to retry. 
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param processorId	ID of the processor which must currently own the transaction
	 * @param timeout		The time that the transaction (if started) will time out
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(can be the new transaction as specified by the argument, or a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent transaction is allowed.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startTransaction(String seriesId, String processorId, Instant timeout, int maxInProgressTransacions, int maxRetryingTransactions)
					throws InfrastructureErrorException{
		SimpleSequentialTransaction transaction = new SimpleSequentialTransaction();
		transaction.setProcessorId(processorId);
		transaction.setTimeout(timeout);
		try {
			return startTransaction(seriesId, null, transaction, maxInProgressTransacions, maxRetryingTransactions);
		} catch (DuplicatedTransactionIdException e) {
			throw Throwables.propagate(e); // should never reach here
		}
	}

	/**
	 * Try to pick up a previously failed transaction to retry. 
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param processorId	ID of the processor which must currently own the transaction
	 * @param timeoutDuration		The duration after which the transaction (if started) will time out
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(can be the new transaction as specified by the argument, or a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent transaction is allowed.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startTransaction(String seriesId, String processorId, Duration timeoutDuration, int maxInProgressTransacions, int maxRetryingTransactions)
					throws InfrastructureErrorException{
		SimpleSequentialTransaction transaction = new SimpleSequentialTransaction();
		transaction.setProcessorId(processorId);
		transaction.setTimeout(timeoutDuration);
		try {
			return startTransaction(seriesId, null, transaction, maxInProgressTransacions, maxRetryingTransactions);
		} catch (DuplicatedTransactionIdException e) {
			throw Throwables.propagate(e);  // should never reach here
		}
	}

	
	/**
	 * Try to pick up a previously failed transaction to retry. 
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param transaction		Details of the new transaction.
	 * 							<br>Fields that cannot be null are:
	 * 									processorId, timeout.
	 * 							<br>Fields that must be null: 
	 * 									startPosition, endPosition.
	 * 							<br>Fields that will be ignored:
	 * 									startTime, finishTime, state, attempts, transactionId, transaction.
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(can be the new transaction as specified by the argument, or a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent transaction is allowed.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startTransaction(String seriesId, ReadOnlySequentialTransaction transaction, int maxInProgressTransacions, int maxRetryingTransactions) 
			throws InfrastructureErrorException{
		try {
			return startTransaction(seriesId, null, transaction, maxInProgressTransacions, maxRetryingTransactions);
		} catch (DuplicatedTransactionIdException e) {
			throw Throwables.propagate(e);  // should never reach here
		}
	}


	/**
	 * Try to start a transaction by either (when transaction.getStartPosition() is null) picking up a previously failed one to retry 
	 * or (when transaction.getStartPosition() is not null) creating a new one to start.
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>If the startPosition of the transaction is not specified in the argument, that means the processor has nothing in mind,
	 *  			then a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 *  <li>If the startPosition of the transaction is specified in the argument, the endPosition must also be specified. In that case
	 *  			the specified transaction will be tried to start. If succeeded, full detail of that transaction will be returned for
	 *  			the processor to work on. </li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId			ID of the transaction series
	 * @param previousTransactionId	ID of previous transaction that the requested one must follow.
	 * 								It can be null if the processor is not requesting the starting of a specific transaction,
	 * 								or if the requested transaction is the very first one (therefore no previous one).
	 * @param transaction		Details of the new transaction.
	 * 							<br>Fields that cannot be null are:
	 * 									processorId, timeout.
	 * 							<br>Fields that cannot be null when requesting the starting of a specific transaction: 
	 * 									startPosition, endPosition.
	 * 							<br>Fields that will be ignored:
	 * 									startTime, finishTime, state, attempts.
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(can be the new transaction as specified by the argument, or a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent transaction is allowed.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws DuplicatedTransactionIdException if the transaction ID specified is duplicated
	 */
	SequentialTransaction startTransaction(String seriesId, String previousTransactionId, ReadOnlySequentialTransaction transaction, int maxInProgressTransacions, int maxRetryingTransactions) 
					throws InfrastructureErrorException, DuplicatedTransactionIdException;
	
	/**
	 * Finish a succeeded transaction. The end position of the transaction can be updated if it is the last transaction.
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the updated end position, or null if there is no need to update it.
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NoSuchTransactionException
	 * @throws IllegalEndPositionException 	if the updated end position creates gap between this and the next transaction, 
	 * 										or if the end position is null.
	 */
	void finishTransaction(String seriesId, String processorId, String transactionId, String endPosition) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException;

	/**
	 * Finish a succeeded transaction. The end position of the transaction will not be updated.
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NoSuchTransactionException
	 * @throws IllegalEndPositionException 	if the end position is null
	 */
	default void finishTransaction(String seriesId, String processorId, String transactionId)
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException{
		finishTransaction(seriesId, processorId, transactionId, null);
	}
	
	/**
	 * Abort a transaction.
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 */
	void abortTransaction(String seriesId, String processorId, String transactionId) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NoSuchTransactionException;
	
	/**
	 * Update the time out of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeout				The new time that the transaction should time out
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws NoSuchTransactionException
	 */
	void renewTransactionTimeout(String seriesId, String processorId, String transactionId, Instant timeout) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NoSuchTransactionException;
	
	/**
	 * Update the time out of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeoutDuration				The period from now after which the transaction should time out
	 * @throws NotOwningTransactionException 
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 * @throws IllegalTransactionStateException 
	 * @throws NoSuchTransactionException
	 */
	default void renewTransactionTimeout(String seriesId, String processorId, String transactionId, Duration timeoutDuration) 
			throws NotOwningTransactionException, InfrastructureErrorException, IllegalTransactionStateException, NoSuchTransactionException{
		Validate.notNull(timeoutDuration, "Transaction time out duration cannot be null");
		renewTransactionTimeout(seriesId, processorId, transactionId, Instant.now().plus(timeoutDuration));
	}
	
	/**
	 * Check if a transaction had succeeded before a specific time
	 * @param seriesId			ID of the transaction series
	 * @param transactionId			ID of the transaction
	 * @param beforeWhen			The time before which we want to know whether the transaction had succeeded or not 
	 * @return	true if the transaction had succeeded in the past or does not exist. false if the transaction is in-progress, aborted, or just succeeded a extremely short while ago.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	boolean isTransactionSuccessful(String seriesId, String transactionId, Instant beforeWhen) throws InfrastructureErrorException;
	
	/**
	 * Check if a transaction has succeeded
	 * @param seriesId			ID of the transaction series
	 * @param transactionId			ID of the transaction
	 * @return	true if the transaction has succeeded in the past or does not exist. false if the transaction is in-progress, aborted, or just succeeded a extremely short while ago.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	default boolean isTransactionSuccessful(String seriesId, String transactionId) throws InfrastructureErrorException{
		return isTransactionSuccessful(seriesId, transactionId, Instant.now());
	}

	/**
	 * Get recent transactions of a progress. 
	 * @param seriesId	ID of the transaction series
	 * @return				List of recent transactions, can be empty if there is no transaction at all. 
	 * 						Head of the list is the last succeeded transaction, tail of the list is the most recent transaction.
	 * @throws InfrastructureErrorException if error in the underlying infrastructure happened
	 */
	List<? extends ReadOnlySequentialTransaction> getRecentTransactions(String seriesId) throws InfrastructureErrorException;

	/**
	 * Clear all the transactions of a progress. This method is not thread safe and should only be used for maintenance.
	 * @param seriesId	ID of the transaction series
	 * @throws InfrastructureErrorException	if error in the underlying infrastructure happened
	 */
	void clear(String seriesId) throws InfrastructureErrorException;

	/**
	 * Clear all the transactions of all transactionsByseriesId. This method is not thread safe and should only be used for maintenance.
	 * @param seriesId	ID of the transaction series
	 * @throws InfrastructureErrorException	if error in the underlying infrastructure happened
	 */
	void clearAll() throws InfrastructureErrorException;
	
	/**
	 * From the list of recent transactions, find out the end position of the last finished transaction before which all transactions had succeeded.
	 * @param transactions	list of transactions returned by {@link #getRecentTransactions(String seriesId)} method.
	 * @return	the last finished position (all transactions before this position has succeeded), or null if there is no recent transaction
	 */
	static String getLastFinishedPosition(List<? extends ReadOnlySequentialTransaction> transactions){
		if (transactions != null){
			String position = null;
			Iterator<? extends ReadOnlySequentialTransaction> iterator = transactions.iterator();
			while(iterator.hasNext()){
				ReadOnlySequentialTransaction tx = iterator.next();
				if (tx.isFinished()){
					position = tx.getEndPosition();
				}else{
					break;
				}
			}
			return position;
		}else{
			return null;
		}
	}
	
	/**
	 * From the list of recent transactions, find out the end position of the last started transaction
	 * @param transactions	list of transactions returned by {@link #getRecentTransactions(String seriesId)} method.
	 * @return	the last position (before this position there might be failed or in progress transactions), or null if there is no recent transaction
	 */
	static String getLastPosition(List<? extends ReadOnlySequentialTransaction> transactions){
		if (transactions != null && transactions.size() > 0){
			ReadOnlySequentialTransaction tx = transactions.get(transactions.size() - 1);
			return tx.getEndPosition();
		}else{
			return null;
		}
	}
	
	/**
	 * From the list of recent transactions, get the number of transaction matching the specified filtering condition
	 * @param transactions	list of transactions returned by {@link #getRecentTransactions(String seriesId)} method.
	 * @param predicate		the filtering condition
	 * @return		number of transactions matching the condition specified
	 */
	static int getTransactionCount(List<? extends ReadOnlySequentialTransaction> transactions, Predicate<ReadOnlySequentialTransaction> predicate){
		if (transactions == null || predicate == null){
			return 0;
		}else{
			return (int) transactions.stream().filter(predicate).count();
		}
	}
}
