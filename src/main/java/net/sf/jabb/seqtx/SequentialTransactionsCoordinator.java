/**
 * 
 */
package net.sf.jabb.seqtx;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;

import net.sf.jabb.seqtx.ex.DuplicatedTransactionIdException;
import net.sf.jabb.seqtx.ex.IllegalEndPositionException;
import net.sf.jabb.seqtx.ex.IllegalTransactionStateException;
import net.sf.jabb.seqtx.ex.TransactionStorageInfrastructureException;
import net.sf.jabb.seqtx.ex.NoSuchTransactionException;
import net.sf.jabb.seqtx.ex.NotOwningTransactionException;

import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import com.google.common.base.Throwables;

/**
 * Coordinator of sequential transactions.
 * For a series of sequential transactions, there can be multiple on-going transactions being handled by different processors at any time.
 * Therefore, there is no need for processors to acquire and hold leases on the whole series.
 * However, all transactions are in a sequence disregarding the reliability of the processors:
 * <ul>
 * 	<li>For any transaction, there is always
 * 		a previous transaction (unless it is the first transaction) and there is no gap or overlap between its startPosition 
 * 		and the endPosition of the previous transaction.</li>
 * 	<li>For any transaction, there is always
 * 		a next transaction (unless it is the last transaction) and there is no gap or overlap between its endPosition 
 * 		and the startPosition of the next transaction.</li>
 * 	<li>Failed transactions (either explicitly aborted by the processor or caused by time out) will be retried until finally succeed.</li>
 * 	<li>Multiple processors can work on different ranges (specified by startPosition and endPosition) at the same time</li>
 * 	<li>There is a way to query whether a transaction has succeeded or 'not sure'</li>
 * </ul>
 * 
 * It is very suitable for coordinating the processing of records in Kafka, Microsoft Azure Event Hub, or Amazon AWS Kinesis.
 * 
 * About transaction IDs:
 * <ul>
 * 	<li>They can be either generated by the service or specified by the client/processor.</li>
 *  <li>The ID should never be a blank string.</li>
 *  <li>They have to be unique within a reasonable time period for any progress but don't need to be unique across transactionsByseriesId.</li>
 * </ul>
 * 
 * About start position and end position:
 * <ul>
 * 	<li>They are provided and interpreted by the application</li>
 *  <li>Start position can never be null</li>
 *  <li>A null end position means the transaction happens on an open range. Open range transactions can only be the last one in a series.
 *  	When finishing an open range transaction, the actual end position must be specified. An aborted or timed out open range transaction will be
 *  	removed therefore cannot be retried.</li>
 *  <li>End position can be updated when finishing the transaction only if the transaction is the last one in the series</li>
 * </ul>
 * 
 * Each processor must have a unique ID of its own.
 * 
 * @author James Hu
 *
 */
public interface SequentialTransactionsCoordinator {
	
	/**
	 * Try to pick up a previously failed transaction to retry. 
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, null will be returned.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param processorId	ID of the processor which must currently own the transaction
	 * @param timeout		The time that the transaction (if started) will time out
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(will always be a previously failed transaction) just started, 
	 * 			or null if no more concurrent in-progress or retrying transaction is allowed.
	 * @throws TransactionStorageInfrastructureException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startAnyFailedTransaction(String seriesId, String processorId, Instant timeout, int maxInProgressTransacions, int maxRetryingTransactions)
					throws TransactionStorageInfrastructureException{
		SimpleSequentialTransaction transaction = new SimpleSequentialTransaction(processorId, timeout);
		
		SequentialTransaction tx = null;
		try {
			tx = startTransaction(seriesId, null, null, transaction, maxInProgressTransacions, maxRetryingTransactions);
		} catch (DuplicatedTransactionIdException e) {
			throw Throwables.propagate(e); // should never reach here
		}
		
		if (tx != null && tx.hasStarted()){		// picked up a failed one to retry
			return tx;
		}else{				// no failed one available for retrying
			return null;
		}
	}

	/**
	 * Try to pick up a previously failed transaction to retry. 
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, null will be returned.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param processorId	ID of the processor which must currently own the transaction
	 * @param timeoutDuration		The duration after which the transaction (if started) will time out
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(will always be a previously failed transaction) just started, 
	 * 			or null if no more concurrent in-progress or retrying transaction is allowed.
	 * @throws TransactionStorageInfrastructureException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startAnyFailedTransaction(String seriesId, String processorId, Duration timeoutDuration, int maxInProgressTransacions, int maxRetryingTransactions)
					throws TransactionStorageInfrastructureException{
		return startAnyFailedTransaction(seriesId, processorId, timeoutDuration == null ? null : Instant.now().plus(timeoutDuration), maxInProgressTransacions, maxRetryingTransactions);
	}


	/**
	 * Try to start a transaction by either (when transaction.getStartPosition() is null) picking up a previously failed one to retry 
	 * or (when transaction.getStartPosition() is not null) creating a new one to start.
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>If the startPosition of the transaction is not specified in the argument, that means the processor has nothing in mind,
	 *  			then a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 *  <li>If the startPosition of the transaction is specified in the argument, the endPosition must also be specified. In that case
	 *  			the specified transaction will be tried to start. If succeeded, full detail of that transaction will be returned for
	 *  			the processor to work on. </li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId			ID of the transaction series
	 * @param previousTransactionId	ID of previous transaction that the requested one must follow.
	 * 								It can be null if the processor is not requesting the starting of a specific transaction,
	 * 								or if the requested transaction is the very first one (therefore no previous one).
	 * @param previousTransactionEndPosition	End position of previous transaction - for concurrency control purpose.
	 * 								It can be null if the processor is not requesting the starting of a specific transaction,
	 * 								or if the requested transaction is the very first one (therefore no previous one).
	 * @param transaction		Details of the new transaction.
	 * 							<br>Fields that cannot be null are:
	 * 									processorId, timeout.
	 * 							<br>Fields that cannot be null when requesting the starting of a specific transaction: 
	 * 									startPosition, endPosition.
	 * 							<br>Fields that will be ignored:
	 * 									startTime, finishTime, state, attempts.
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(can be the new transaction as specified by the argument, or a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent transaction is allowed.
	 * @throws TransactionStorageInfrastructureException if error in the underlying infrastructure happened
	 * @throws DuplicatedTransactionIdException if the transaction ID specified is duplicated
	 */
	SequentialTransaction startTransaction(String seriesId, String previousTransactionId, String previousTransactionEndPosition, ReadOnlySequentialTransaction transaction, int maxInProgressTransacions, int maxRetryingTransactions) 
					throws TransactionStorageInfrastructureException, DuplicatedTransactionIdException;
	
	/**
	 * Try to pick up a previously failed transaction to retry. If there is none available, request a skeleton for creating a new transaction.
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param processorId	ID of the processor which must currently own the transaction
	 * @param timeout		The time that the transaction (if started) will time out
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(will always be a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent in-progress or retrying transaction is allowed.
	 * @throws TransactionStorageInfrastructureException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startTransaction(String seriesId, String processorId, Instant timeout, int maxInProgressTransacions, int maxRetryingTransactions) 
					throws TransactionStorageInfrastructureException{
		try {
			return startTransaction(seriesId, null, null, new SimpleSequentialTransaction(processorId, timeout), maxInProgressTransacions, maxRetryingTransactions);
		} catch (DuplicatedTransactionIdException e) {
			throw Throwables.propagate(e); // should never reach here
		}
	}
	
	/**
	 * Try to pick up a previously failed transaction to retry. If there is none available, request a skeleton for creating a new transaction.
	 * <ul>
	 * 	<li>If the number of currently in progress transactions already reached maxConcurrentTransacions, then return null which means no transaction can be started now.</li>
	 * 	<li>If the number of currently retrying previously failed transactions is less than maxRetryingTransactions, 
	 * 				and there is at least one previously failed transaction needs retry, then that transaction will be started for retry.
	 * 				Full detail of that transaction will be returned for the processor to work on.</li>
	 *  <li>Otherwise, a new transaction will be proposed to the processor. Partial detail of the proposed transaction will be returned for
	 *  			the processor to complete and then to request starting it in a following call to this method.</li>
	 * </ul>
	 * The returned object can be safely modified by the caller and reused for other purposes.
	 * @param seriesId	ID of the transaction series
	 * @param processorId	ID of the processor which must currently own the transaction
	 * @param timeoutDuration		Duration after which the transaction (if started) will time out
	 * @param maxInProgressTransacions	maximum number of concurrent transaction
	 * @param maxRetryingTransactions	maximum number of retrying transactions
	 * @return Full information (hasStarted() returns true, transactionId is not null, startTime is not null) of a transaction 
	 * 			(will always be a previously failed transaction) just started, 
	 * 			or a skeleton (hasStarted() returns false, transactionId is the ID of the previous one or null if this is the very first one, 
	 * 			startTime is null, startPosition is the endPosition of the previous one or null if this is the very first one, 
	 * 			endPosition is null) of a proposed transaction,
	 * 			or null if no more concurrent in-progress or retrying transaction is allowed.
	 * @throws TransactionStorageInfrastructureException if error in the underlying infrastructure happened
	 */
	default SequentialTransaction startTransaction(String seriesId, String processorId, Duration timeoutDuration, int maxInProgressTransacions, int maxRetryingTransactions) 
					throws TransactionStorageInfrastructureException{
		return startTransaction(seriesId, processorId, timeoutDuration == null ? null : Instant.now().plus(timeoutDuration), maxInProgressTransacions, maxRetryingTransactions);
	}
	
	/**
	 * Finish a succeeded transaction. The end position of the transaction can be updated if it is the last transaction.
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the updated end position, or null if there is no need to update it.
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws IllegalEndPositionException 	if the updated end position creates gap between this and the next transaction, 
	 * 										or if the end position is null.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	void finishTransaction(String seriesId, String processorId, String transactionId, String endPosition) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException;

	/**
	 * Finish a succeeded transaction. The end position of the transaction will not be updated.
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws IllegalEndPositionException 	if the updated end position creates gap between this and the next transaction, 
	 * 										or if the end position is null.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	default void finishTransaction(String seriesId, String processorId, String transactionId)
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException{
		finishTransaction(seriesId, processorId, transactionId, null);
	}
	
	/**
	 * Abort a transaction.
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	void abortTransaction(String seriesId, String processorId, String transactionId) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException;
	
	/**
	 * Update the end position and time out of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the new end position. It can be null indicating that there is no need to change the end position.
	 * 								Only the end position of the last transaction can be updated.
	 * @param timeout				The new time that the transaction should time out. It can be null indicating that there is no need to change the timeout.
	 * @param detail				Transaction detail to be updated. It can be null indicating that there is no need to update.
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 * @throws IllegalEndPositionException 	if the updated end position creates gap between this and the next transaction.
	 */
	void updateTransaction(String seriesId, String processorId, String transactionId, String endPosition, Instant timeout, Serializable detail) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException;
	
	/**
	 * Update the end position and time out of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the new end position. It can be null indicating that there is no need to change the end position.
	 * 								Only the end position of the last transaction can be updated.
	 * @param timeoutDuration		The new duration after which the transaction should time out. It can be null indicating that there is no need to change the timeout.
	 * @param detail				Transaction detail to be updated. It can be null indicating that there is no need to update.
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 * @throws IllegalEndPositionException 	if the updated end position creates gap between this and the next transaction.
	 */
	default void updateTransaction(String seriesId, String processorId, String transactionId, String endPosition, Duration timeoutDuration, Serializable detail) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException{
		updateTransaction(seriesId, processorId, transactionId, endPosition, timeoutDuration == null ? null : Instant.now().plus(timeoutDuration), detail);
	}
	
	/**
	 * Update the end position of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param endPosition			the new end position. It can not be null.
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 * @throws IllegalEndPositionException 	if the updated end position creates gap between this and the next transaction.
	 */
	default void updateTransactionEndPosition(String seriesId, String processorId, String transactionId, String endPosition) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException, IllegalEndPositionException{
		Validate.notNull(endPosition, "end position cannot be null");
		updateTransaction(seriesId, processorId, transactionId, endPosition, (Instant)null, null);
	}
	
	/**
	 * Update the time out of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeout				The new time that the transaction should time out
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	default void renewTransactionTimeout(String seriesId, String processorId, String transactionId, Instant timeout) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException{
		Validate.notNull(timeout, "Transaction time out cannot be null");
		try {
			updateTransaction(seriesId, processorId, transactionId, null, timeout, null);
		} catch (IllegalEndPositionException e) {
			throw Throwables.propagate(e); // should never reach here
		} 
	}
	
	/**
	 * Update the time out of a transaction
	 * @param seriesId			ID of the transaction series
	 * @param processorId			ID of the processor which must currently own the transaction
	 * @param transactionId			ID of the transaction
	 * @param timeoutDuration				The period from now after which the transaction should time out
	 * @throws NoSuchTransactionException  If the transaction does not exist in the list of recent transactions.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws NotOwningTransactionException If the transaction is not currently owned by the processor.
	 * 									For example, if a transaction previously owned by processor A timed out, it may be picked up by processor B
	 * 									for retry. If after that the processor A wants to finish the transaction, it will
	 * 									get this exception because the transaction is then owned by processor B 
	 * @throws IllegalTransactionStateException If the transaction is not currently in a state that can be finished.
	 * 											For example, if the transaction already timed out.
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	default void renewTransactionTimeout(String seriesId, String processorId, String transactionId, Duration timeoutDuration) 
			throws NotOwningTransactionException, TransactionStorageInfrastructureException, IllegalTransactionStateException, NoSuchTransactionException{
		Validate.notNull(timeoutDuration, "Transaction time out duration cannot be null");
		renewTransactionTimeout(seriesId, processorId, transactionId, Instant.now().plus(timeoutDuration));
	}
	
	/**
	 * Check if a transaction had succeeded at a specific time
	 * @param seriesId			ID of the transaction series
	 * @param transactionId			ID of the transaction
	 * @param beforeOrAtMoment			The time before which we want to know whether the transaction had succeeded or not 
	 * @return	True if the transaction had succeeded in the past or does not exist in the list of recent transactions; 
	 * 				False if the transaction is in-progress, aborted, or just succeeded a extremely short while ago.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	boolean isTransactionSuccessful(String seriesId, String transactionId, Instant beforeOrAtMoment) throws TransactionStorageInfrastructureException;
	
	/**
	 * Check if a transaction has succeeded
	 * @param seriesId			ID of the transaction series
	 * @param transactionId			ID of the transaction
	 * @return	True if the transaction had succeeded in the past or does not exist in the list of recent transactions; 
	 * 				False if the transaction is in-progress, aborted, or just succeeded a extremely short while ago.
	 * 									A transaction may be removed from the list when both itself and its next transaction
	 * 									finished successfully, or when an open range transaction (which can only be the last one) failed (aborted or timed out).
	 * @throws TransactionStorageInfrastructureException If error in the underlying infrastructure happened, in this case, usually
	 * 										no immediate retry should be attempted.
	 */
	default boolean isTransactionSuccessful(String seriesId, String transactionId) throws TransactionStorageInfrastructureException{
		return isTransactionSuccessful(seriesId, transactionId, Instant.now());
	}

	/**
	 * Get recent transactions of a progress. 
	 * @param seriesId	ID of the transaction series
	 * @return				List of recent transactions, can be empty if there is no transaction at all. 
	 * 						Head of the list is the last succeeded transaction, tail of the list is the most recent transaction.
	 * @throws TransactionStorageInfrastructureException if error in the underlying infrastructure happened
	 */
	List<? extends ReadOnlySequentialTransaction> getRecentTransactions(String seriesId) throws TransactionStorageInfrastructureException;

	/**
	 * Clear all the transactions of a progress. This method is not thread safe and should only be used for maintenance.
	 * @param seriesId	ID of the transaction series
	 * @throws TransactionStorageInfrastructureException	if error in the underlying infrastructure happened
	 */
	void clear(String seriesId) throws TransactionStorageInfrastructureException;

	/**
	 * Clear all the transactions of all transactionsByseriesId. This method is not thread safe and should only be used for maintenance.
	 * @throws TransactionStorageInfrastructureException	if error in the underlying infrastructure happened
	 */
	void clearAll() throws TransactionStorageInfrastructureException;
	
	/**
	 * From the list of recent transactions, find out the end position of the last finished transaction before which all transactions had succeeded.
	 * @param transactions	list of transactions returned by {@link #getRecentTransactions(String seriesId)} method.
	 * @return	the last finished position (all transactions before this position has succeeded), or null if there is no recent transaction
	 */
	static String getFinishedPosition(List<? extends ReadOnlySequentialTransaction> transactions){
		if (transactions != null){
			String position = null;
			Iterator<? extends ReadOnlySequentialTransaction> iterator = transactions.iterator();
			while(iterator.hasNext()){
				ReadOnlySequentialTransaction tx = iterator.next();
				if (tx.isFinished()){
					position = tx.getEndPosition();
				}else{
					break;
				}
			}
			return position;
		}else{
			return null;
		}
	}
	
	/**
	 * From the list of recent transactions, find out the end position of the last started transaction
	 * @param transactions	list of transactions returned by {@link #getRecentTransactions(String seriesId)} method.
	 * @return	the last position (before this position there might be failed or in progress transactions), or null if there is no recent transaction
	 */
	static String getLastPosition(List<? extends ReadOnlySequentialTransaction> transactions){
		if (transactions != null && transactions.size() > 0){
			ReadOnlySequentialTransaction tx = transactions.get(transactions.size() - 1);
			return tx.getEndPosition();
		}else{
			return null;
		}
	}
	
	/**
	 * From the list of recent transactions, get the number of transaction matching the specified filtering condition
	 * @param transactions	list of transactions returned by {@link #getRecentTransactions(String seriesId)} method.
	 * @param predicate		the filtering condition
	 * @return		number of transactions matching the condition specified
	 */
	static int getTransactionCount(List<? extends ReadOnlySequentialTransaction> transactions, Predicate<ReadOnlySequentialTransaction> predicate){
		if (transactions == null || predicate == null){
			return 0;
		}else{
			return (int) transactions.stream().filter(predicate).count();
		}
	}
	
	/**
	 * Counts about transaction, it includes retrying count, in progress count, and failed count.
	 * Both first attempting and retrying are considered as in progress.
	 * Both timed out and aborted are considered as failed.
	 * @author James Hu
	 *
	 */
	static class TransactionCounts{
		private int retrying;
		private int inProgress;
		private int failed;
		
		TransactionCounts(int inProgress, int retrying, int failed){
			this.inProgress = inProgress;
			this.retrying = retrying;
			this.failed = failed;
		}
		
		@Override
		public String toString(){
			return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
		}
		
		/**
		 * @return the retrying
		 */
		public int getRetrying() {
			return retrying;
		}
		/**
		 * @return the inProgress
		 */
		public int getInProgress() {
			return inProgress;
		}
		/**
		 * @return the failed
		 */
		public int getFailed() {
			return failed;
		}
	}
	
	/**
	 * Get counts about a collection of transactions
	 * @param transactions		the collection of transactions
	 * @return		counts
	 */
	static TransactionCounts getTransactionCounts(Collection<? extends ReadOnlySequentialTransaction> transactions){
		int inProgress = 0;
		int retrying = 0;
		int failed = 0;
		
		if (transactions != null && transactions.size() > 0){
			for (ReadOnlySequentialTransaction tx: transactions){
				switch(tx.getState()){
					case IN_PROGRESS:
						inProgress ++;
						if (tx.getAttempts() > 1){
							retrying ++;
						}
						break;
					case FINISHED:
						break;
					default:	// failed
						failed ++;
						break;
				}
			}
		}
		return new TransactionCounts(inProgress, retrying, failed);
	}
	

}
